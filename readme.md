## IoC\DI Spring

 - **Inversion of Control** (IoC - инверсия управления) - принцип программирования, при котором управление выполнением программы передается фреймворку, а не прграммисту. Происходит потеря контроля над выполнением кода: фреймворк управляет кодом программиста, а не программист управляет фреймворком.

 - **Dependency Injection** (DI – внедрение зависимостей) – одна из реализаций IoC, посредством которой созданием объекта и компоновкой его зависимостей занимается другой объект (фреймворк).

### Фреймворк определяет и внедряет зависимости через:
 - параметры конструктора
 - параметры статического метода инициализации (фабричный метод)
 - свойства объекта (set* методы)
### IoC Container
 - **IoC Container** - объект, который занимается созданием других объектов и внедрением в них зависимостей (DI). Обычно представлен в виде обычного ассоциативного массива (Map), где ключом является String, а значением наш объект со всеми его зависимостями (bean). Реализует несколько интерфейсов:
1. org.springframework.beans.factory.BeanFactory - фабрика бинов.
2. org.springframework.context.ApplicationContext - реализует BeanFactory и предоставляет более широкий список методов для работы с бинами.
 - **Bean** - объект со всеми необходимыми зависимостями, который был создан с помощью **IoC Container** (Controller, Service, Repository).  

Для того, чтобы были созданы Bean, нужно предоставить в IoC Container некоторую информацию о них:
 - **Metadata** - представляет собой совокупность объектов (Bean Definitions), которые говорят IoC Container как создавать Beans, конфигурировать и внедрять их зависимости. (Bean Definition как чертеж, а Bean - деталь, созданная по этому чертежу).  

Metadata (Bean Definitions) могут создаваться тремя способами:
1. XML-based
2. Annotation-based
3. Java-based
 - **POJO** - обычный объект с набором свойств, конструкторов и get\set методами. Не содержит логики (DTO, Entity).

Контекст.
Если передать в контекст другой контекст, то переданный контекст станет родительским для текущего. Это дает возможность использовать один контекст с функциональностью и бинами из различных источников.  
Представляется в виде ассоциативного массива *Map<String, Object>*
### XML-based
Создание контекста на основании XML.
1. Добавляем создание нового контекста new ClassPathXmlApplicationContext("application.xml"). *Файл может быть с другим названием.*
2. Добавляем файл application.xml, где указываем bean definitions для бинов.
   - Атрибут **<bean class="Class_name.class">** - главный и основной для создания бина. *Для создания бина будет вызван конструктор по умолчанию (или другой указанный) у класса Class_name.class через ReflectionAPI*.
   - Если не указывать идентификатор, то для имени бина берется название его класса и добавляется #0. Второй такой же бин получит имя с #1 и тп.
   - Если получать бины по классу, имея несколько бинов одного класса, то будет Exception, т.к. Spring не поймет, какой бин вернуть. 
   - Лучше определить параметр **id** в атрибуте **<bean...>** для идентификации бинов, затем получать их добавляя тип: getBean("bean_name", Bean_class.class). Иначе придется приводить к типу.
   - Параметр **name** в атрибуте **<bean...>** Используется для того, чтобы дать более красивое название бина в приложении (alias). *Можно использовать для получения бинов. Хранятся в отдельной aliasMap (мапятся на соответствующий идентификатор бинов).*
   - Все bean definitions контекста можно найти в "context" -> BeanFactory -> BeanDefinitionMap. Где ключ - название бина, а значение его Bean definition (метаинформация), на основании которого будет создан бин.
   - Все Singleton bean можно найти в context -> singletonObjects.
   - Атрибут **<constructor-arg ...>** используется для указания параметров конструктора.
     1. Параметр **value** в теге <constructor-arg> используется для указания **примитивных** параметров конструктора.
     2. Если просто указывать аргументы, то важен порядок аргументов. Иначе значения будут устанавливаться не в те параметры.
     3. Spring сам конвертирует примитивные значения в нужные типы. Для list используется дополнительный тег **<list><value>**, для map: **<map><entry>**.
     4. Есть возможность явно добавить тип аргумента, добавив параметр **type** в тег <constructor-arg>.
     5. Можно указать параметр **index=номер_по_порядку** в теге <constructor-arg...> для каждого параметра, тогда очередность не будет играть роли.
     6. Альтернативно и более наглядно использовать параметр **name=имя_параметра** в теге <constructor-arg...> для каждого параметра.