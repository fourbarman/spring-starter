## IoC\DI Spring

 - **Inversion of Control** (IoC - инверсия управления) - принцип программирования, при котором управление выполнением программы передается фреймворку, а не прграммисту. Происходит потеря контроля над выполнением кода: фреймворк управляет кодом программиста, а не программист управляет фреймворком.

 - **Dependency Injection** (DI – внедрение зависимостей) – одна из реализаций IoC, посредством которой созданием объекта и компоновкой его зависимостей занимается другой объект (фреймворк).

## Фреймворк определяет и внедряет зависимости через:
 - **параметры конструктора. Плюс в том, что все поля final, а значит immutable.**
 - **параметры статического метода инициализации (фабричный метод)**. В бине есть статический метод, возвращающий новый объект бина. Конструктор при этом private.
 - **свойства объекта (set* методы)**. Нужны set методы, значит нельзя указывать поля как final. А значит объект будет не immutable. Есть возможность сделать циклические зависимости в бинах (в отличие от метода через констпуктор). Зато удобно использовать, когда есть optonal зависимость.
## IoC Container
 - **IoC Container** - объект, который занимается созданием других объектов и внедрением в них зависимостей (DI). Обычно представлен в виде обычного ассоциативного массива (Map), где ключом является String, а значением наш объект со всеми его зависимостями (bean). Реализует несколько интерфейсов:
1. org.springframework.beans.factory.BeanFactory - фабрика бинов.
2. org.springframework.context.ApplicationContext - реализует BeanFactory и предоставляет более широкий список методов для работы с бинами.
 - **Bean** - объект со всеми необходимыми зависимостями, который был создан с помощью **IoC Container** (Controller, Service, Repository).  

Для того, чтобы были созданы Bean, нужно предоставить в IoC Container некоторую информацию о них:
 - **Metadata** - представляет собой совокупность объектов (Bean Definitions), которые говорят IoC Container как создавать Beans, конфигурировать и внедрять их зависимости. (Bean Definition как чертеж, а Bean - деталь, созданная по этому чертежу).  

Metadata (Bean Definitions) могут создаваться тремя способами:
1. XML-based
2. Annotation-based
3. Java-based
 - **POJO** - обычный объект с набором свойств, конструкторов и get\set методами. Не содержит логики (DTO, Entity).

Контекст.
Если передать в контекст другой контекст, то переданный контекст станет родительским для текущего. Это дает возможность использовать один контекст с функциональностью и бинами из различных источников.  
Представляется в виде ассоциативного массива *Map<String, Object>*
## XML-based
Создание контекста на основании XML.
1. Добавляем создание нового контекста new ClassPathXmlApplicationContext("application.xml"). *Файл может быть с другим названием.*
2. Добавляем файл application.xml, где указываем bean definitions для бинов.
   - Атрибут **<bean class="Class_name.class">** - главный и основной для создания бина. *Для создания бина будет вызван конструктор по умолчанию (или другой указанный) у класса Class_name.class через ReflectionAPI*.
   - Если не указывать идентификатор, то для имени бина берется название его класса и добавляется #0. Второй такой же бин получит имя с #1 и тп.
   - Если получать бины по классу, имея несколько бинов одного класса, то будет Exception, т.к. Spring не поймет, какой бин вернуть. 
   - Лучше определить параметр **id** в атрибуте **<bean...>** для идентификации бинов, затем получать их добавляя тип: getBean("bean_name", Bean_class.class). Иначе придется приводить к типу.
   - Параметр **name** в теге **<bean...>** используется для того, чтобы дать более красивое название бина в приложении (alias). *Можно использовать для получения бинов. Хранятся в отдельной aliasMap (мапятся на соответствующий идентификатор бинов).*
   - Все bean definitions контекста можно найти в "context" -> BeanFactory -> BeanDefinitionMap. Где ключ - название бина, а значение его Bean definition (метаинформация), на основании которого будет создан бин.
   - Все Singleton bean можно найти в context -> singletonObjects.
   - Тег **<constructor-arg ...>** тега используется для указания параметров конструктора.
     1. Параметр **value** в теге <constructor-arg> используется для указания **примитивных** параметров конструктора.
     2. Если просто указывать аргументы, то важен порядок аргументов. Иначе значения будут устанавливаться не в те параметры.
     3. Spring сам конвертирует примитивные значения в нужные типы. Для list используется дополнительный тег **<list><value>**, для map: **<map><entry>**.
     4. Есть возможность явно добавить тип аргумента, добавив параметр **type** в тег <constructor-arg>.
     5. Можно указать параметр **index=номер_по_порядку** в теге <constructor-arg...> для каждого параметра, тогда очередность не будет играть роли.
     6. Альтернативно и более наглядно использовать параметр **name=имя_параметра** в теге <constructor-arg...> для каждого параметра.
     7. Параметр **value-ref** (для map entry) или **ref** (для всех остальных) в теге <constructor-arg> используется для указания **ссылочных** параметров конструктора, например ссылок на другие бины.
   - **factory-method** в теге **<bean...>** используется при DI через фабричный метод. В бине должен быть специальный статический метод.
   - **factory-bean** в теге **<bean...>** используется при DI через фабричный метод. Указывается бин, который предоставит другие бины - там будет происходить создание объектов (как обычная фабрика).
   - тег **property** в теге **<bean...>** используется при DI через set методы.

## Bean scopes  
#### Типы бинов
1. **Common** - Общие (ApplicationContext):
    - **singleton** - всегда в одном экземпляре. Хранятся в context в singletonObjects (map).
    - **prototype** - каждый раз создается новый бин, когда он запрашивается у ApplicationContext. Не хранятся в context, сразу отдаются тому, кто попросил.
    - **thread** (SimpleThreadScope) - используется, чтобы создавать бины соответствующему потоку. Но нужно подключать его отдельно:  
        ```java 
        Scope threadScope = new SimpleThreadScope();
        context.registerScope("thread", threadScope);
        ```
2. **Web** (WebApplicationContext)
    - **request** - для каждого запроса по HTTP создается новый бин.
    - **session** - для каждой HTTP сессии создается новый бин.
    - **application** - на ServletContext создается новый бин.
    - **websocket**
3. **Custom**
    1. реализуем интерфейс org.springframework.beans.factory.config.**Scope**
    2. регистрируем созданный scope через **ConfigurableBeanFactory.registerScope()**
## Lifecycle Callbacks
После того как вызвали set методы, можем вызвать еще какие-то методы для последующей инициализации, утилизации.  
**Методы должны быть void и не должны принимать никаких параметров.**  
Если используется несколько вариантов callbacks, то порядок вызова будет именно такой, как указан ниже.
#### Initialization Callbacks
1. **@PostConstruct** - *нужны анотации* - предпочтительный
2. **afterPropertiesSet()** - *реализация интерфейса initializingBean*
3. **init-method** - *xml*
#### Destruction Callbacks (только для sigleton beans)
Методы, которые будут вызываться, когда context закрывается (нужно явно вызвать метод close(), например обернув в try-with-resources).  
Используются например для очистки ресурсов.
1. **@PreDestroy** - *нужны анотации* - предпочтительный
2. **destroy()** - *DisposableBean*
3. **destroy-method** - *xml*